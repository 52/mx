#!/usr/bin/env bash
#
# USAGE:
#   swayrun [-?|--debug] [-h|--help] [OPTIONS...] PROGRAM
#
# OPTIONS:
#   -?, --debug               -- Enables debug (verbose) mode.
#   -h, --help                -- Displays this help message.
#   -t, --timeout [number]    -- The wait timeout in deciseconds (default: 100).
#   -w, --workspace [number]  -- The target workspace ID (default: current).
#   

# Get the script directory.
DIRECTORY="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source the 'trace' functions.
source "${DIRECTORY}/trace"

# List of required dependencies.
DEPENDENCIES=(swaymsg jq)

# Assert that we have the dependencies installed.
for dep in "${DEPENDENCIES[@]}"; do
  if ! command -v "$dep" >/dev/null 2>&1; then
    error "'$dep' not found, exiting process..."
    exit 1
  fi
done

# Assert that sway is running.
if ! swaymsg -t get_version >/dev/null 2>&1; then
  error "Unable to connect to sway, exiting process..."
  exit 1
fi

# Set the debug mode flag.
DEBUG=0

# Set the default timeout.
TIMEOUT=100

# Set the target workspace.
WORKSPACE=""

# Parse the command line options.
while [[ $# -gt 0 ]]; do
  case "$1" in
    -\?|--debug)
      DEBUG=1
      shift
      ;;
    -h|--help)
      sed -n '2,/^$/s/^# \?//p' "$0"
      exit 0
      ;;
    -t|--timeout)
      TIMEOUT="$2"
      shift 2
      ;;
    -w|--workspace)
      WORKSPACE="$2"
      shift 2
      ;;
    *)
      break
      ;;
  esac
done

# Assert that a program was specified.
if [[ $# -eq 0 ]]; then
  error "No program specified, exiting process..."
  exit 1
fi

# Get the program to run.
PROGRAM="$1"
shift

# Assert that the program exists.
if ! command -v "$PROGRAM" >/dev/null 2>&1; then
  error "Program '$PROGRAM' not found, exiting process..."
  exit 1
fi

# Get the current workspace.
CURRENT_WORKSPACE=$(swaymsg -t get_workspaces | jq -r '.[] | select(.focused==true) | .name')

# Use the current workspace, if not otherwise specified.
if [[ -z "$WORKSPACE" ]]; then
  WORKSPACE="$CURRENT_WORKSPACE"
fi

# Switch to target workspace.
if [[ "$WORKSPACE" != "$CURRENT_WORKSPACE" ]]; then
  if [[ "$DEBUG" -eq 1 ]]; then
    debug "Switching to workspace '$WORKSPACE'"
  fi

  swaymsg "workspace $WORKSPACE" >/dev/null
fi

if [[ "$DEBUG" -eq 1 ]]; then
  debug "Starting '$PROGRAM' in workspace '$WORKSPACE'"
fi

# Start the program.
"$PROGRAM" "$@" &
PID=$!

# Assert that the program has started.
if ! kill -0 "$PID" 2>/dev/null; then
  error "Failed to start program, exiting process..."
  exit 1
fi

if [[ "$DEBUG" -eq 1 ]]; then
  debug "Waiting for '$PROGRAM' to start (PID: $PID)"
fi

# Track the elapsed time.
ELAPSED=0

# Track whether the loop was successful.
SUCCESS=0

# Create marker files for IPC.
MARKER_FILE="/tmp/swayrun.$$.$RANDOM.success"
PID_FILE="/tmp/swayrun.$$.$RANDOM.pid"
echo "$PID" > "$PID_FILE"

# Subscribe to sway window events.
swaymsg -t subscribe -m '[ "window" ]' | while read -r event; do
  # Extract the app_id from the event.
  APP_ID=$(echo "$event" | jq -r '.container.app_id // empty')

  # Extract the instance from the event.
  INSTANCE=$(echo "$event" | jq -r '.container.window_properties.instance // empty')

  if [[ "$DEBUG" -eq 1 ]] && [[ -n "$APP_ID" ]]; then
    debug "Window appeared while waiting for '$PROGRAM' (APP_ID: $APP_ID)"
  fi

  if [[ "$DEBUG" -eq 1 ]] && [[ -n "$INSTANCE" ]]; then
    debug "Window appeared while waiting for '$PROGRAM' (INSTANCE: $INSTANCE)"
  fi

  # Assert that the window is the one we're interested in.
  if [[ "${APP_ID,,}" == "${PROGRAM,,}" ]] || [[ "${INSTANCE,,}" == "${PROGRAM,,}" ]]; then
    WINDOW_ID=$(echo "$event" | jq -r '.container.id')
    
    if [[ "$DEBUG" -eq 1 ]]; then
      debug "Window appeared for program '$PROGRAM' (WINDOW_ID: $WINDOW_ID)"
    fi
    
    # Move the window to the specified workspace.
    swaymsg "[con_id=$WINDOW_ID] move container to workspace $WORKSPACE" >/dev/null
    
    # Create the marker file.
    touch "$MARKER_FILE"
    
    # Exit the process.
    exit 0
  fi
done &

# Capture the monitor process ID.
MONITOR_PID=$!

# Wait for the window to appear or timeout.
while [[ $ELAPSED -lt $TIMEOUT ]]; do
  # Assert that the marker file was created.
  if [[ -f "$MARKER_FILE" ]]; then
    SUCCESS=1
    break
  fi
  
  sleep 0.1
  ELAPSED=$((ELAPSED + 1))
done

# Clean up the marker file.
rm -f "$MARKER_FILE" "$PID_FILE"

# Clean up the monitor process.
kill $MONITOR_PID 2>/dev/null

# Exit the script.
if [[ $SUCCESS -eq 1 ]]; then
  if [[ "$DEBUG" -eq 1 ]]; then
    debug "Successfully started '$PROGRAM' in workspace '$WORKSPACE'"
  fi
  exit 0
else
  error "Timed out waiting for window for '$PROGRAM' (PID: $PID), exiting process..."
  kill "$PID" 2>/dev/null
  exit 1
fi
